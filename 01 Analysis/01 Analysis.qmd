---
title: "Coupon Acceptance"
format: ipynb
editor: source
jupyter: python3
---

# Will a Customer Accept the Coupon?

**Context**

Imagine driving through town and a coupon is delivered to your cell phone for a restaraunt near where you are driving. Would you accept that coupon and take a short detour to the restaraunt? Would you accept the coupon but use it on a sunbsequent trip? Would you ignore the coupon entirely? What if the coupon was for a bar instead of a restaraunt? What about a coffee house? Would you accept a bar coupon with a minor passenger in the car? What about if it was just you and your partner in the car? Would weather impact the rate of acceptance? What about the time of day?

Obviously, proximity to the business is a factor on whether the coupon is delivered to the driver or not, but what are the factors that determine whether a driver accepts the coupon once it is delivered to them? How would you determine whether a driver is likely to accept a coupon?

**Overview**

The goal of this project is to use what you know about visualizations and probability distributions to distinguish between customers who accepted a driving coupon versus those that did not.

**Data**

This data comes to us from the UCI Machine Learning repository and was collected via a survey on Amazon Mechanical Turk. The survey describes different driving scenarios including the destination, current time, weather, passenger, etc., and then ask the person whether he will accept the coupon if he is the driver. Answers that the user will drive there ‘right away’ or ‘later before the coupon expires’ are labeled as ‘Y = 1’ and answers ‘no, I do not want the coupon’ are labeled as ‘Y = 0’.  There are five different types of coupons -- less expensive restaurants (under \\$20), coffee houses, carry out & take away, bar, and more expensive restaurants (\\$20 - \\$50).

**Deliverables**

Your final product should be a brief report that highlights the differences between customers who did and did not accept the coupons.  To explore the data you will utilize your knowledge of plotting, statistical summaries, and visualization using Python. You will publish your findings in a public facing github repository as your first portfolio piece. 

## Data Description
Keep in mind that these values mentioned below are average values.

1\. User attributes

-   gender: male, female
-   age: below 21, 21 to 25, 26 to 30, etc.
-   maritalStatus: single, married partner, unmarried partner, or widowed
-   has_children: 0, 1
-   education: high school, bachelors degree, associates degree, or graduate degree
-   occupation: architecture & engineering, business & financial, etc.
-   income: (annual) less than \$12500, \$12500 - \$24999, \$25000 - \$37499, etc.
-   Bar: Number of times that he/she goes to a bar: 0, less than 1, 1 to 3, 4 to 8 or greater than 8
-   CoffeeHouse: Number of times that he/she goes to a coffee house: 0, less than 1, 1 to 3, 4 to 8 or
    greater than 8
-   CarryAway: Number of times that he/she buys takeaway food: 0, less than 1, 1 to 3, 4 to 8 or greater
    than 8
-   RestaurantLessThan20: Number of times that he/she eats at a restaurant with average expense less than \\$20 per
    person: 0, less than 1, 1 to 3, 4 to 8 or greater than 8
-   Restaurant20To50: Number of times that he/she eats at a restaurant with average expense less than \\$20 per
    person: 0, less than 1, 1 to 3, 4 to 8 or greater than 8

2\. Contextual attributes

-   destination: home, work, or no urgent destination
-   passenger: alone, partner, kid(s), or friend(s)
-   weather: sunny, rainy, or snowy
-   temperature: 30F, 55F, or 80F - Time: 10AM, 2PM, or 6PM
-   time: closest time of day (7AM, 10AM, 2PM, 6PM, 10PM)
-   toCoupon_GEQ5min: is coupon destination within 5 minutes of driver (1)
-   toCoupon_GEQ15min: Is coupon destination within 5 minutes of driver (0, 1)
-   toCoupon_GEQ25min: Is coupon destination within 5 minutes of driver (0, 1)
-   direction_same: Is restaurant in the same direction as driver currently headed (?) (0, 1)
-   direction_opp: Is restraurant in opposite direction as driver's current trajectory (0, 1)

3\. Coupon attributes

-   coupon type: Bar, Coffee House, Carry out & Take away, Restaurant (<20), Restaurant (20 - 50)
-   time before it expires: 2 hours or one day

4\. Results
-   Y: did customer accept the coupon (0, 1)

**NOTE: I use the `plotnine` package for plotting, in most instances**
```{python}
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import plotly.express as px
from plotnine import ggplot, aes, labs
import plotnine as ggp

def cprint(text: str, color: str = 'yellow'):
  """Uses a few basic colors to print messages/warnings to the console."""
  lookup_dict = {'black': 30, 'red': 31, 'green': 32, 'yellow': 33, 'blue': 34, 'magenta': 35, 'cyan': 36, 'white': 37,
                 'bred': 91, 'bgreen':92, 'byellow': 93, 'bblue': 94, 'bmagenta': 95, 'bcyan': 96, 'bwhite': 97}
  if color not in lookup_dict.keys():
    message = "Color not in code. Possible values: " + str(list(lookup_dict.keys()))
    cprint(text = message, color = '31')
    return
  print("\033[{}m{}\033[00m".format(lookup_dict[color], text))
  return
```

## Problems

Use the prompts below to get started with your data analysis.  

1. Read in the `coupons.csv` file.
```{python}
data = pd.read_csv("../00 Data/coupons.csv")
cprint("HEAD")
data.head()
cprint("COLUMNS")
data.columns
```
### Automated EDA
```{python}
from ydata_profiling import ProfileReport

profile = ProfileReport(data, title = "Coupn Dataset: Profiling Report")
profile.to_file(output_file='coupon_profile.html')

profile
```
The file `coupon_profile.html` can be used to examine multiple details about the dataset, but will not be the focus of this assignment.

### Data values and unique value counts

Below, values and proportions are printed out. This helps me to familiarize myself with the data as well as serving as a reference to return to later.
```{python}
# Get counts of unique values for each column & print them out
for colName in data.columns:
  val_number = pd.DataFrame(data[colName].value_counts(dropna = False))
  val_number['prop'] = val_number['count']/sum(val_number['count'])
  val_number['prop'] = val_number['prop'].round(decimals = 2)
  cprint(str.upper(colName) + ". Value count: " + str(val_number.shape[0]) + ". Series type: " + str(data[colName].dtype))
  print(val_number)
```

2. Investigate the dataset for missing or problematic data.
```{python}
# rename 'passanger' column
data = data.rename(axis = 1, mapper = {"passanger": "passenger"})

# counts of missing data
data.isna().sum()
```
3. Decide what to do about your missing data -- drop, replace, other...

Missingness for all variables except `car` either nonexistant or very low, and likely due to legitimate missingness (i.e., not all customers will go to bars, coffee houses, etc.). `car` is odd; very low response rates and possibly a constructed resposne option jugding by the comment about OnStar. However, the fact this exact comment occurs 21 times is odd. Explore why that is.
```{python}
no_onstar_data = data.query("car == 'Car that is too old to install Onstar :D'")
no_onstar_data
```

The user attributes (age, gender, etc.) never change, strongly suggesting that this one person is represented 21 times in the data for different events; this assumedly holds true for other persons in the dataset as well. This means many of the observations are not independent since they are for the same person; however, without an identifier column it becomes impossible to identify who is who, meaning we could not control for that factor. Therefore our dataset violates the assumption of independence of observations. We cannot use inferential statistics on this dataset as is, and the conclusions we can justifiably make from this are extremely limited. However, we can still use descriptive statistics to reach some tentative conclusions.

Since this is an exercise I will continue on as if all observations were independent.

For now: remove the `car` column and keep the other data.
```{python}
data = data.drop('car', axis = 'columns')
data.columns
```

4. What proportion of the total observations chose to accept the coupon? 
```{python}
# since Y is a Boolean represented numerically as 0 and 1, easiest way to get a proportion is via the variable's mean
data.Y.mean()
```
~57% of observations accepted the coupon

5. Use a bar plot to visualize the `coupon` column.
```{python}
(
  ggplot(data, aes(x = "coupon", fill = "coupon")) +
  ggp.geom_bar(color = 'black') + labs(x = "Coupon", y = "Count", title = 'Bar Plot of Coupon Type') +
  ggp.theme(legend_position = 'none')
)
```

6. Use a histogram to visualize the temperature column.
```{python}
(ggplot(data, aes(x = 'temperature')) + ggp.geom_histogram())
```

The data appears to have been binned for easier use; histogram is not an acceptable way to show this information.
```{python}
data2 = data
data2['temperature'] = data2['temperature'].astype('str')

# use plotly to visualize this time
fig = px.bar(data2.sort_values('temperature'), x = 'temperature', color = 'temperature', color_discrete_sequence = ['blue', '#008000', 'red'])
fig.update_traces(dict(marker_line_width=0))
fig.show()
```

## Investigating the Bar Coupons

Now, we will lead you through an exploration of just the bar related coupons.  

1. Create a new `DataFrame` that contains just the bar coupons.
```{python}
bar_data = data.query("coupon == 'Bar'")
bar_data.coupon.value_counts()
```

2. What proportion of bar coupons were accepted?
```{python}
bar_data.Y.mean()
```
~41% were accepted

3. Compare the acceptance rate between those who went to a bar 3 or fewer times a month to those who went more.
```{python}
bar_data.Bar.value_counts(dropna = False)

# drop those who didn't respond for now
bar_data = bar_data.loc[~bar_data['Bar'].isna(),:]
```

Create summary variable for analysis
```{python}
# True: Did not go to bar 4+ times
bar_data['three_or_less'] = (bar_data['Bar'].isin(['never', 'less1', '1~3'])).tolist()
bar_data['Y_text'] = bar_data['Y'].isin([1]).tolist()

cprint("Three or less")
bar_data[['three_or_less', 'Bar']].value_counts(dropna = False)
cprint("Yes/No")
bar_data[['Y', 'Y_text']].value_counts(dropna = False)
```

```{python}
bar_counts = pd.DataFrame(bar_data[['three_or_less', 'Y_text']].value_counts(dropna = False))
bar_counts['prop'] = round(bar_counts['count']/sum(bar_counts['count']), 2)
bar_counts['prop_in_three_or_less'] = round(bar_counts['count']/bar_counts.groupby('three_or_less').sum('count')['count'], 2)
bar_counts = bar_counts.reset_index().sort_values(['three_or_less', 'Y_text'])
print(bar_counts)
(
  ggplot(bar_counts, aes(x = "three_or_less", y = "prop_in_three_or_less", fill = 'Y_text')) +
  ggp.geom_bar(position = 'dodge', stat = 'identity', color = 'black') +
  labs(fill = "Accepted Coupon", x = "Under 3x/month", y = 'Proportion (grouped in Under/Over 3x Month)')
)
```

When customers go to the bar 3 or fewer times per month, they are *less* likely to accept a bar coupon than they are to reject one. If they go to the bar 4 or more times per month, they are *more* likely to accept a bar coupon than they are to reject one.

4. Compare the acceptance rate between drivers who go to a bar more than once a month and are over the age of 25 to the all others.  Is there a difference?
```{python}
bar_data.age.value_counts(dropna = False).sort_index()
```

```{python}
# True: 26+ and drivers
bar_data['over_25'] = (~bar_data['age'].isin(['21', 'below21'])).tolist()
bar_data['more_once_month'] = (~bar_data['Bar'].isin(['never', 'less1'])).tolist()
bar_data['both_true'] = (bar_data['over_25'] & bar_data['more_once_month'])

cprint("Over 25")
bar_data[['over_25', 'age']].value_counts().sort_index()
cprint("More 1x/Month")
bar_data[['more_once_month', 'Bar']].value_counts().sort_index()
cprint("Both")
bar_data[['both_true', 'over_25', 'more_once_month']].value_counts().sort_index()
```
Compare acceptance rates
```{python}
both_counts = pd.DataFrame(bar_data[['both_true', 'Y_text']].value_counts().sort_index())
both_counts['prop'] = round(both_counts['count']/sum(both_counts['count']), 2)
both_counts['prop_both_true'] = round(both_counts['count']/both_counts.groupby('both_true').sum('count')['count'], 2)
both_counts = both_counts.reset_index().sort_values(['both_true', 'Y_text'])
(
  ggplot(both_counts, aes(x = "both_true", y = "prop_both_true", fill = 'Y_text')) +
  ggp.geom_bar(position = 'dodge', stat = 'identity', color = 'black') +
  labs(fill = "Accepted Coupon", x = "Both True (Over 25 & Go to bar >= 1x/month)", y = 'Proportion (Grouped by Both True)')
)
```
Those who are over 25 and go to a bar at least once a month are about twice as likely to accept the coupon to a bar as they are to reject it.


5. Use the same process to compare the acceptance rate between drivers who go to bars more than once a month and had passengers that were not a kid and had occupations other than farming, fishing, or forestry. 
```{python}
cprint("PASSENGER")
bar_data['passenger'].value_counts(dropna = False)
cprint("OCCUPATION")
bar_data['occupation'].value_counts(dropna = False)
```
```{python}
bar_data['passenger_notkid'] = bar_data['passenger'].isin(['Friend(s)', 'Partner'])
bar_data['occupation_not_fff'] = ~bar_data['occupation'].isin(['Farming Fishing & Forestry'])
bar_data['all_true_2'] = bar_data['passenger_notkid'] & bar_data['occupation_not_fff'] & bar_data['more_once_month']

cprint("Passenger - Not kid")
bar_data[['passenger_notkid', 'passenger']].value_counts().sort_index()
cprint("Occupatino - Not FFF")
bar_data[['occupation_not_fff', 'occupation']].value_counts().sort_index()
cprint("All")
bar_data[['all_true_2', 'passenger_notkid', 'occupation_not_fff', 'more_once_month']].value_counts().sort_index()
```
Compare acceptance rates

Because I keep doing the same counting operation repeatedly, going to make a function to facilitate everything
```{python}
def getPropFrame(dataframe, count_column: str, yes_column: str):
  """ dataframe: data ; count_column: column to categorize by ; yes_column: accepted/not """
  temporary = pd.DataFrame(dataframe[[count_column, yes_column]].value_counts().sort_index())
  temporary['prop'] = round(temporary['count']/sum(temporary['count']), 2)
  new_colname = 'prop_' + count_column
  temporary[new_colname] = round(temporary['count']/temporary.groupby(count_column).sum('count')['count'], 2)
  temporary = temporary.reset_index().sort_values([count_column, yes_column])
  return temporary
```


```{python}
all_2_counts = getPropFrame(bar_data, 'all_true_2', 'Y_text')

# all_2_counts = pd.DataFrame(bar_data[['all_true_2', 'Y_text']].value_counts().sort_index())
# all_2_counts['prop'] = round(all_2_counts['count']/sum(all_2_counts['count']), 2)
# all_2_counts['prop_all_true_2'] = round(all_2_counts['count']/all_2_counts.groupby('all_true_2').sum('count')['count'], 2)
# all_2_counts = all_2_counts.reset_index().sort_values(['all_true_2', 'Y_text'])
(
  ggplot(all_2_counts, aes(x = "all_true_2", y = "prop_all_true_2", fill = 'Y_text')) +
  ggp.geom_bar(position = 'dodge', stat = 'identity', color = 'black') +
  labs(fill = "Accepted Coupon",
       x = "All True (Go to bar >= 1x/month & Not-kid passenger & Not in FFF)",
       y = 'Proportion (Grouped by All True)')
)
```

6. Compare the acceptance rates between those drivers who:

- go to bars more than once a month, had passengers that were not a kid, and were not widowed *OR*
- go to bars more than once a month and are under the age of 30 *OR*
- go to cheap restaurants more than 4 times a month and income is less than 50K.
```{python}
cprint("Marital Status")
bar_data['maritalStatus'].value_counts(dropna = False)
cprint("Restaurant Habits")
bar_data['RestaurantLessThan20'].value_counts(dropna = False)
cprint("Income")
bar_data['income'].value_counts(dropna = False).sort_index()
cprint("Age")
bar_data['age'].value_counts(dropna = False).sort_index()
```

```{python}
# Group1: go to bars more than once a month, had passengers that were not a kid, and were not widowed
# Group2: go to bars more than once a month and are under the age of 30
# Group3: go to cheap restaurants more than 4 times a month and income is less than 50K
# Group_all: Group1 OR Group2 OR Group3
bar_data['Group1'] = bar_data['more_once_month'] & bar_data['passenger_notkid'] & ~bar_data['maritalStatus'].isin(['Widowed'])
bar_data['Group2'] = bar_data['more_once_month'] & bar_data['age'].isin(['below21', '21', '26'])
bar_data['Group3'] = bar_data['RestaurantLessThan20'].isin(['4~8', 'gt8']) & bar_data['income'].isin(['Less than $12500', '$12500 - $24999', '$25000 - $37499', '$37500 - $49999'])
bar_data['Group_all'] = bar_data['Group1'] | bar_data['Group2'] | bar_data['Group3']

cprint("Group1")
bar_data[['Group1', 'maritalStatus', 'more_once_month', 'passenger_notkid']].value_counts().sort_index()
cprint("Group2")
bar_data[['Group2', 'more_once_month', 'age']].value_counts().sort_index()
cprint("Group3")
bar_data[['Group3', 'RestaurantLessThan20', 'income']].value_counts().sort_index()
cprint("Group_all")
bar_data[['Group_all', 'Group1', 'Group2', 'Group3']].value_counts()
```

Compare acceptance rates
```{python}
group_all_counts = getPropFrame(bar_data, 'Group_all', 'Y_text')

# group_all_counts = pd.DataFrame(bar_data[['Group_all', 'Y_text']].value_counts().sort_index())
# group_all_counts['prop'] = round(group_all_counts['count']/sum(group_all_counts['count']), 2)
# group_all_counts['prop_Group_all'] = round(group_all_counts['count']/group_all_counts.groupby('Group_all').sum('count')['count'], 2)
# group_all_counts = group_all_counts.reset_index().sort_values(['Group_all', 'Y_text'])
(
  ggplot(group_all_counts, aes(x = "Group_all", y = "prop_Group_all", fill = 'Y_text')) +
  ggp.geom_bar(position = 'dodge', stat = 'identity', color = 'black') +
  labs(fill = "Accepted Coupon",
       x = "Any True",
       y = 'Proportion (Grouped by Any True)')
)
```

7.  Based on these observations, what do you hypothesize about drivers who accepted the bar coupons?

Based on these observations, we can assume that belonging to any one of these groups increases the likelihood of them accepting a coupon.

## Independent Investigation: 'Carry out & Take away'

I chose to explore the 'Carry out & Take away' coupon category, particularly examining whether:
-   Having children makes a difference when children are or are not in the car
-   Whether the distance and/or direction of the restaurant mattered

Create the DataFrame for analysis
```{python}
ca_data = data.query("coupon == 'Carry out & Take away'")
ca_data.coupon.value_counts()
```
Does having children make a difference to accepting these coupons? What about when children are NOT in the car, vs. when they are?
```{python}
cprint("Has Children")
ca_data['has_children'].value_counts(dropna = False)
cprint("Passenger")
ca_data['passenger'].value_counts(dropna = False)
```
Visualization using Seaborn
```{python}
ca_data['took_coupon'] = ca_data['Y'].isin([1])
ca_data['has_children_text'] = ca_data['has_children'].isin([1])

kids_count = getPropFrame(ca_data, 'has_children_text', 'took_coupon')

# kids_count = pd.DataFrame(ca_data[['has_children_text', 'took_coupon']].value_counts().sort_index())
# kids_count['prop'] = round(kids_count['count']/sum(kids_count['count']), 2)
# kids_count['prop_has_children_text'] = round(kids_count['count']/kids_count.groupby('has_children_text').sum('count')['count'], 2)
# kids_count = kids_count.reset_index()
#group_all_counts = group_all_counts.reset_index().sort_values(['Group_all', 'Y_text'])

plt.clf()
sns.barplot(kids_count, x = 'has_children_text', y = 'prop_has_children_text', hue = 'took_coupon')
plt.show() ; plt.clf()
```
Just having children seems to make no difference; most people who were offered a CarryAway coupon chose to accept it.
What if those with children did not have children in the car? (Also compare to those who do not have kids)
```{python}
# Using three columns, so not using function earlier defined
passenger_count = pd.DataFrame(ca_data[['has_children_text', 'passenger', 'took_coupon']].value_counts().sort_index())
passenger_count['prop'] = round(passenger_count['count']/sum(passenger_count['count']), 2)
passenger_count['prop_passenger'] = round(passenger_count['count']/passenger_count.groupby(['passenger', 'has_children_text']).sum('count')['count'], 2)
passenger_count = passenger_count.reset_index()

sns.catplot(passenger_count, kind = "bar", x = 'passenger', hue = 'took_coupon', y = 'prop_passenger', row = 'has_children_text')
plt.show() ; plt.clf()
```

It seems that, regardless of how these categories are split up, the rate of acceptance of CarryAway coupons remains fairly constant, at about ~60% - 75% acceptance rate.

So, what about if the restaurant for which the coupon is for is on the way towards the customer's destination, and/or is fairly close by?
```{python}
ca_data[['direction_same', 'direction_opp']].value_counts()
# direction_same and direction_opposite are the inverse of each other; can just use one

ca_data[['toCoupon_GEQ5min', 'toCoupon_GEQ15min', 'toCoupon_GEQ25min']].value_counts(dropna = False).sort_index()
# looks like this denotes a range; '1' if the restaurant is within that time range (e.g., if the restaurant was 4 minutes away, all three columns would read '1'; if 10 minutes, `5min` would be '0' but the others woudl be '1', etc.)

# create that array below
ca_data['toCoupon_time'] = (np.select(
  condlist = [
    ca_data['toCoupon_GEQ15min'].isin([0]) & ca_data['toCoupon_GEQ25min'].isin([0]), # 0 - 5 minutes
    ca_data['toCoupon_GEQ15min'].isin([1]) & ca_data['toCoupon_GEQ25min'].isin([0]), # 5 - 15 minutes
    ca_data['toCoupon_GEQ15min'].isin([1]) & ca_data['toCoupon_GEQ25min'].isin([1])  # 15 - 25 minutes
  ],
  choicelist = ['0 - 05 minutes', '05 - 15 minutes', '15 - 25 minutes'],
  default = np.nan)).tolist()

ca_data[['toCoupon_GEQ5min', 'toCoupon_GEQ15min', 'toCoupon_GEQ25min', 'toCoupon_time']].value_counts().sort_index()
```

``` {python}
ca_data['direction_same_text'] = ca_data['direction_same'].isin([1])

dir_count = pd.DataFrame(ca_data[['direction_same_text', 'toCoupon_time', 'took_coupon']].value_counts().sort_index())
dir_count['prop'] = round(dir_count['count']/sum(dir_count['count']), 2)
dir_count['prop_direction_and_time'] = round(dir_count['count']/dir_count.groupby(['direction_same_text', 'toCoupon_time']).sum('count')['count'], 2)
dir_count = dir_count.reset_index()

#group_all_counts = group_all_counts.reset_index().sort_values(['Group_all', 'Y_text'])

sns.catplot(dir_count, kind = 'bar', x = 'toCoupon_time', y = 'prop_direction_and_time', hue = 'took_coupon', row = 'direction_same_text')
plt.show() ; plt.clf()
```

Again, we see that the rates of acceptance are pretty constant across groups. Even when controlling for time and direction of restaurant, customers usually take the coupon between 70% - 80% of the time. The one exception seems to be for customers where the restaurant was 5 - 15 minutes away; they accepted the coupons more often but only ~60% of the time. Notably, there was never an instance where the restaurant was over 15 minutes away in the opposite direction. Perhaps this is because the designers of this pilot program predetermined that these coupons would almost never be accepted, and so never offered coupons in this situation. (The fact that the proportions are changing for the `05 - 15 minutes` group suggests that this assumption may have been at least partially correct!)